; >>>> begin comments
;==========================================================================================
;
; >>>> McObject Class: sdi2k_prog_fox
;
; This file contains the McObject method code for sdi2k_prog_fox objects:
;
; Mark Conde (Mc), Fairbanks, October 2000.
;
; >>>> end comments
; >>>> begin declarations
;         menu_name = Focus Tests
;        class_name = sdi2k_prog_fox
;       description = SDI Program - Focus Tester
;           purpose = SDI operation
;       idl_version = 5.2
;  operating_system = Windows NT4.0 terminal server 
;            author = Mark Conde
; >>>> end declarations


;==========================================================================================
; This is the (required) "new" method for this McObject:

pro sdi2k_prog_fox_new, instance, dynamic=dyn, creator=cmd
;---First, properties specific to this object:
    cmd = 'instance = {sdi2k_prog_fox, '
    cmd = cmd + 'specific_cleanup: ''sdi2k_prog_fox_specific_cleanup'', '    
;---Now add fields common to all SDI objects. These will be grouped as sub-structures:
    sdi2k_common_fields, cmd, automation=automation, geometry=geometry
;---Next, add the required fields, whose specifications are read from the 'declarations'
;   section of the comments at the top of this file:
    whoami, dir, file    
    obj_reqfields, dir+file, cmd, dynamic=dyn
;---Now, create the instance:
    status = execute(cmd)
end

;==========================================================================================
; This is the event handler for events generated by the sdi2k_prog_fox object:
pro sdi2k_prog_fox_event, event
    widget_control, event.top, get_uvalue=info
    wid_pool, 'Settings: ' + info.wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=fox_settings
    if widget_info(event.id, /valid_id) and fox_settings.automation.show_on_refresh then widget_control, event.id, /show

;---Check for a timer tick:    
    if tag_names(event, /structure_name) eq 'WIDGET_TIMER' then begin
       sdi2k_prog_fox_tik, info.wtitle
       if fox_settings.automation.timer_ticking then widget_control, widx, timer=fox_settings.automation.timer_interval
       return
    endif
    
;---Check for a new frame event sent by the control module:
    nm      = 0
    matched = where(tag_names(event) eq 'NAME', nm)
    if nm gt 0 then begin
       if event.(matched(0)) eq 'NewFrame' then sdi2k_prog_fox_tik, info.wtitle
       return
    endif

;---Get the menu name for this event:
    widget_control, event.id, get_uvalue=menu_item
    if n_elements(menu_item) eq 0 then menu_item = 'Nothing valid was selected'
end

;==========================================================================================
; This is the routine that updates the actual plot:
pro sdi2k_prog_fox_tik, wtitle, redraw=redraw, _extra=_extra
@sdi2kinc.pro
common fox_com, fox_accum, fox_history
;---Get settings information for this instance of the output xwindow and this instance of 
;   the plot program itself:
    wid_pool, wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=info
    wid_pool, 'Settings: ' + wtitle, sidx, /get
    if not(widget_info(sidx, /valid_id)) then return
    widget_control, sidx, get_uvalue=fox_settings

    host.programs.focus.update_count = host.programs.focus.update_count + 1
    sdi2k_etalon_gap
    if n_elements(fox_accum) eq 0 then fox_accum = intarr(n_elements(view(*,0)), n_elements(view(0,*)))
    fox_accum = fox_accum + view
    
    if host.programs.focus.update_count ge host.programs.focus.update_divisor then begin
       host.programs.focus.update_count = 0
       if !d.name ne 'Z' and !d.name ne 'PS' then wset, info.wid
       freakz = fft(fox_accum - total(fox_accum)/n_elements(fox_accum))
       freakz = float(freakz*conj(freakz))
       freakz = freakz/max(freakz)
       freakz = freakz*(float(dist(n_elements(freakz(*,0)), n_elements(freakz(0,*))))^4)
       sharp  = total(freakz)/1e5
       if fox_history(0) eq -1 then fox_history = sharp else fox_history = [fox_history, sharp]
       if n_elements(fox_history) gt 1 then $
          plot, fox_history, title='Focus History', xtitle='Sample Number', ytitle='Sharpness', $
                charsize=2, xthick=2, ythick=2, psym=-1, symsize=0.9, color=host.colors.wheat
          xyouts, 0.85, 0.25, strcompress('Current: ' + string(sharp, format='(f12.2)')), $
                  color=host.colors.white, charsize=2, align=1, charthick=2, /normal
       fox_accum = intarr(n_elements(view(*,0)), n_elements(view(0,*)))
    endif

    widget_control, sidx, set_uvalue=fox_settings
;---Check if we need to make a GIF file:
    ;sdi2k_plugin_gif, info, js_time=timlimz(1)
end

;==========================================================================================
;   Cleanup jobs:
pro sdi2k_prog_fox_specific_cleanup, widid
@sdi2kinc.pro
    if host.controller.scheduler.job_semaphore eq 'No scheduled job' then $
       sdi2k_set_shutters, camera='closed', laser='closed'
end

;==========================================================================================
; This is the (required) "autorun" method for this McObject. If no autorun action is 
; needed, then this routine should simply exit with no action:

pro sdi2k_prog_fox_autorun, instance
@sdi2kinc.pro
common fox_com, fox_accum, fox_history
    instance.geometry.xsize = 900
    instance.geometry.ysize = 600
    instance.automation.timer_interval = 1.
    instance.automation.timer_ticking = 0
    fox_history = -1
    if host.controller.scheduler.job_semaphore eq 'No scheduled job' then $
       sdi2k_set_shutters, camera='open', laser='closed'
    mnu_xwindow_autorun, instance, topname='sdi2k_top'    
end

;==========================================================================================
; This is the (required) class method for creating a new instance of the sdi2k_prog_fox object. It
; would normally be an empty procedure.  Nevertheless, it MUST be present, as the last procedure in 
; the methods file, and it MUST have the same name as the methods file.  By calling this
; procedure, the caller forces all preceeding routines in the methods file to be compiled, 
; and so become available for subsequent use:

pro sdi2k_prog_fox
end

