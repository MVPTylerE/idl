;==========================================================================
; This IDL procedure can be used to read netCDF data files generated by the 
; Poker Flat Scanning Doppler Imager. 

; Mark Conde, Fairbanks, July 2001.

;==========================================================================
;
;  This is the main part of the sdi2k_load procedure

pro sdi2k_load, fname, $
              settings=settings
            level_zero=level_zero, $
             level_one=level_one, $
             level_two=level_two, $
                 zones=zones, $
             meta_data=meta_data, $
              messages=messages
         
    if not(keyword_set(settings)) then l2k_defset_load, settings
    l2k_open, fname,      ncid,  messages
    l2k_read_meta_data,   ncid,  meta_data, messages 
    l2Ksdi_build_zonemap, zones, meta_data, settings, messages 


;---Read the data stored in the file:
    for j=0,meta_data.records-1 do begin
        l2k_lev0_read, j. ncid, level_zero, settings, messages 
        l2k_lev1_read, j, ncid, level_one,  settings, messages 
        l2k_lev2_read, j, nicd, level_two,  settings, messages 
    endfor
    ncdf_close, ncid

    if n_elements(level_two) eq 0 then l2k_compute_lev2, level_one, level_two, settings, messages
end

pro l2k_defset_load, settings
    settings = {use_lev2_if_present: 'Yes', $
           calculate_lev2_if_absent: 'Yes', $
                 temporal_smoothing: 0.8, $
                  spatial_smoothing: 0.05, $
                 wind_fit_algorithm: 'Fourier', $
                    force_zero_dvdx: 'No'}
                 
end

;==============================================================================================
;   This procedure adds a new message to the array 'messages'
pro l2k_add_message, text=text, whom=whom, severity=severity, messages
    if not(keyword_set(text))     then text     = 'Unknown message'
    if not(keyword_set(whom))     then whom     = 'Unkown origin'
    if not(keyword_set(severity)) then severity = 'Unknown severity'
    
    now = dt_tm_mak(js2jd(0d)+1, dt_tm_tojs(systime()), format='Y$-n$-0d$ h$:m$')
    this_msg = {s_msg, text:text, whom: whom, severity:severity, when: now}
    if n_elements(messages) eq 0 then messages = this_msg else messages = [messages, this_message]
end 

;==============================================================================================
;   This procedure opens an SDI netCDF file:
pro l2k_open, fname, ncid, messages
    ncid = -1
    if file_test(fname, /read, /regular) then ncid = ncdf_open (fname, /write)
    if ncid eq -1 then begin
       l2k_add_message, text='Unable to open file: ' + fname, whom='l2k_open', severity='Fatal', messages
       return
    endif

;---This is a bug workaround - sometimes, it takes sevearl attempts to re-enter DEFINE mode for these files: 
    on_error, 3
    on_ioerror, f1

    ncdf_control, ncid, /verbose
    ncdf_control, ncid, /sync

    ncdf_control, ncid, /redef
f1:
    ncdf_control, ncid, /abort
    ncid = ncdf_open(fname, /write)
    ncdf_control, ncid, /redef
    ncdf_control, ncid, /endef
    ncdf_control, ncid, /sync
end
    
;==============================================================================================
;   This procedure reads the meta data from the netCDF file:
pro l2k_read_meta_data, ncid, meta_data, messages 

;------Get data dimensions:
       dummy = 'Return Name'
       ncdf_diminq, ncid, ncdf_dimid(ncid, 'Time'),    dummy,  maxrec
       ncdf_diminq, ncid, ncdf_dimid(ncid, 'Zone'),    dummy,  nzones
       ncdf_diminq, ncid, ncdf_dimid(ncid, 'Channel'), dummy,  nchan
       ncdf_diminq, ncid, ncdf_dimid(ncid, 'Ring'),    dummy,  nrings

;------Read any 'Note' attributes found in the netCDF file:
       i = 0
       ncdf_attget, ncid, 'Note_' + string(i, format='(i2.2)'), note, /global
       xx = strcompress(string(note), /remove_all)
       while strlen(xx) gt 1 do begin
             if n_elements(note_array) eq 0 then note_array = note else note_array = [note_array, note]
             ncdf_attget, ncid, 'Note_' + string(i, format='(i2.2)'), note, /global
             xx = strcompress(string(note), /remove_all)
       endwhile

;------Define the meta-data structure:
       meta_data = {time_records: maxrec, $
                   viewing_zones: nzones, $
          spectral_scan_channels: nchan,  $
              zenith_angle_rings: nrings, $
                   earliest_time: 0D,  $
                     latest_time: 0D,  $
                      ring_radii: intarr(nrings), $
                         sectors: intarr(nrings), $
                  x_center_pixel: -1., $
                  y_center_pixel: -1., $
                   etalon_gap_mm: -1., $
          etalon_scan_start_step: -1,  $
          etalon_gap_nm_per_step: -1., $
     etalon_gap_refractive_index: -1., $
               sky_wavelength_nm: -1., $
               cal_wavelength_nm: -1., $
          cal_temperature_kelvin: -1., $
                    sky_mass_amu: -1., $
                    cal_mass_amu: -1., $
          sky_reflective_finesse: -1., $
          cal_reflective_finesse: -1., $
           sky_field_of_view_deg: -1., $
                       site_name: 'Unknown', $
                       site_code: 'Unknown', $
                  site_longitude: -1., $
                   site_latitude: -1., $
                   operator_name: 'Unknown', $
                operator_comment: 'Unknown', $
                  operator_notes: note_array}

;------Get information regarding times, if the existing file has any:
       if maxrec gt 0 then begin
          ncdf_varget, ncid, ncdf_varid(ncid, 'Start_Time'), stime,   offset=(0), count=(1)
          ncdf_varget, ncid, ncdf_varid(ncid, 'End_Time'),   etime,   offset=(maxrec-1), count=(1)
          meta_data.earliest_time = stime
          meta_data.latest_time   = etime
       endif

;------Get static variables:
       ncdf_varget, ncid, ncdf_varid(ncid, 'FOV_Rings'),            fovr,    offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Ring_Radii'),           radii,   offset=0, count=fovr
       ncdf_varget, ncid, ncdf_varid(ncid, 'Sectors'),              sectors, offset=0, count=fovr
       ncdf_varget, ncid, ncdf_varid(ncid, 'X_Center'),             xcen,    offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Y_Center'),             ycen,    offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Gap'),                  gap,     offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Start_Spacing'),        strtspc, offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Scan_Channels'),        nchan,   offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Nm_Per_Step'),          nmps,    offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Gap_Refractive_Index'), refidx,  offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Sky_Wavelength'),       lamsky,  offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Cal_Wavelength'),       lamcal,  offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Cal_Temperature'),      caltemp, offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Sky_Mass'),             skymass, offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Cal_Mass'),             calmass, offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Sky_Ref_Finesse'),      skynr,   offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Cal_Ref_Finesse'),      calnr,   offset=0, count=1
       ncdf_varget, ncid, ncdf_varid(ncid, 'Sky_FOV'),              fov,     offset=0, count=1

       host.operation.zones.ring_radii            = radii
       host.operation.zones.sectors               = sectors
       host.operation.zones.fov_rings             = fovr
       host.operation.zones.x_center              = xcen
       host.operation.zones.y_center              = ycen
       host.hardware.etalon.gap                   = gap
       host.hardware.etalon.start_spacing         = strtspc
       host.hardware.etalon.scan_channels         = nchan
       host.hardware.etalon.nm_per_step           = nmps
       host.hardware.etalon.gap_refractive_index  = refidx
       host.operation.calibration.sky_wavelength  = lamsky
       host.operation.calibration.cal_wavelength  = lamcal
       host.operation.calibration.cal_temperature = caltemp
       host.operation.calibration.sky_mass        = skymass
       host.operation.calibration.cal_mass        = calmass
       host.operation.calibration.sky_ref_finesse = skynr
       host.operation.calibration.cal_ref_finesse = calnr
       host.operation.calibration.sky_fov         = fov

;------Get global attributes:
       ncdf_attget, ncid, 'Site',           site,   /GLOBAL
       ncdf_attget, ncid, 'Site_Code',      sitecd, /GLOBAL
       ncdf_attget, ncid, 'Start_Day_UT',   doy,    /GLOBAL
       ncdf_attget, ncid, 'Year',           year,   /GLOBAL
       ncdf_attget, ncid, 'Longitude',      lon,    /GLOBAL
       ncdf_attget, ncid, 'Latitude',       lat,    /GLOBAL
       ncdf_attget, ncid, 'Operator',       oper,   /GLOBAL
       ncdf_attget, ncid, 'Comment',        cmt,    /GLOBAL
       
       host.operation.header.site      = string(site)
       host.operation.header.site_code = string(sitecd)
       host.operation.header.doy       = string(doy)
       host.operation.header.year      = string(year)
       host.operation.header.longitude = lon
       host.operation.header.latitude  = lat
       host.operation.header.operator  = string(oper)
       host.operation.header.comment   = string(cmt)

;------Read the notes back from the file:
       for i=0,n_elements(host.operation.header.notes)-1 do begin
           ncdf_attget, ncid, 'Note_' + string(i, format='(i2.2)'), note, /global
           host.operation.header.notes(i) = string(note)
       endfor
       

end


;####################################
sdi_ut_index
sdi_zonal_averages
poly_filter, timarr, aparr, /lowpass
sdi_physical_units
sdi_remove_radial_residual
if keyword_set(spacesmooth) then begin
   print, 'Smoothing winds in space...'
   empty
   sdi_spacesmooth_fits, posarr, spacesmooth
endif
if keyword_set(timesmooth)  then begin
   print, 'Smoothing winds in time...'
   empty
   sdi_timesmooth_fits,  posarr, timesmooth
endif
sdi_uniform_wind, dvdx_zero=dvdx_zero
zonwind = zonal(*, 0: ncrecord-1)
merwind = merid(*, 0: ncrecord-1)
zenwind = posarr(0,0: ncrecord-1)
delzen  = sposarr(0,0: ncrecord - 1)
temperature = widarr(0,0: ncrecord-1)
deltemp = swidarr(0,0: ncrecord-1)
timarr  = timarr(0: ncrecord-1)

if not(keyword_set(fulltime)) then begin
   sectime = timarr - 86400d*(fix(timarr/86400d))
endif else begin
   sectime = double(timarr); + ymds2js(1970, 1, 1, 0)
endelse

if keyword_set(zones) then begin
   sdi_build_zonemap
   zones = {delta_lon: xx, $
            delta_lat: yy, $
                  map: zone_map, $
              centers: zone_centers(*,0:1), $
               pixels: zone_centers(*,2), $
                  rad: rad,  $
                theta: theta}
endif
end


pro sdi_data_init
@sdi_inc.pro
       ipd_pixels = 256
       shrink  = 5.1
       mapix   = ipd_pixels/shrink
       satval  = 255
       rbwmin  = 1
       rbwmax  = 75
       dopmin  = 76
       dopmax  = 150
       greymin = 151
       greymax = 225
       sectors = intarr(8)
       positions   = fltarr(64)
       areas       = fltarr(64)
       widths      = fltarr(64)
       sigpos      = fltarr(64)
       sigarea     = fltarr(64)
       sigwid      = fltarr(64)
       backgrounds = fltarr(64)
       chi_squared = fltarr(64)
       sig2noise   = fltarr(64) + 5
       posarr      = positions
       widarrr     = widths
       britearr    = areas
       sposarr     = sigpos
       swidarrr    = sigwid
       sbritearr   = sigarea
       basearr     = backgrounds
       aparr       = fltarr(1)
       abarr       = fltarr(1)
       awarr       = fltarr(1)
       chiarr      = chi_squared
       snrarr      = sig2noise
       centime     = 0L
       timarr      = lonarr(1)
       zone_map    = intarr(mapix, mapix)
       frame    = 0
       avpos    = 999.
       avwid    = 999.
       avarea   = 999.
       utixarr  = intarr(800)
       end

pro sdi_ncopen, file, sdi2000=sdi2000
@sdi_inc.pro

       if keyword_set(sdi2000) then begin
          radstring = 'Ring_Radii'
          gapstring = 'Gap'
       endif else begin
          radstring = 'Ring_Radius'
          gapstring = 'Plate_Spacing'
       endelse
       
       ncdims    = intarr(4)
       ncvars    = intarr(64) - 1
       ncrecord  = 0
       ncid = ncdf_open (file)
       ncdims(0) = ncdf_dimid (ncid, 'Time')
       ncdims(1) = ncdf_dimid (ncid, 'Zone')
       ncdims(2) = ncdf_dimid (ncid, 'Channel')
       ncdims(3) = ncdf_dimid (ncid, 'Ring')

       ncvars(0) = ncdf_varid (ncid, 'Start_Time')
       ncvars(1) = ncdf_varid (ncid, 'End_Time')
       ncvars(2) = ncdf_varid (ncid, 'Spectra')
       ncvars(3) = ncdf_varid (ncid, 'Number_Summed')
       ncvars(4) = ncdf_varid (ncid, radstring)
       ncvars(5) = ncdf_varid (ncid, 'Sectors')
       ncvars(6) = ncdf_varid (ncid, gapstring)
       ncvars(7) = ncdf_varid (ncid, 'Start_Spacing')
       ncvars(8) = ncdf_varid (ncid, 'Channel_Spacing')
       ncvars(9) = ncdf_varid (ncid, 'Scan_Channels')
       ncvars(10)= ncdf_varid (ncid, 'Gap_Refractive_Index')
       ncvars(11)= ncdf_varid (ncid, 'Sky_Wavelength')
       ncvars(12)= ncdf_varid (ncid, 'Cal_Wavelength')
       ncvars(13)= ncdf_varid (ncid, 'Cal_Temperature')
       ncvars(14)= ncdf_varid (ncid, 'Sky_Mass')
       ncvars(15)= ncdf_varid (ncid, 'Cal_Mass')
       ncvars(16)= ncdf_varid (ncid, 'Sky_Ref_Finesse')
       ncvars(17)= ncdf_varid (ncid, 'Cal_Ref_Finesse')
       ncvars(18)= ncdf_varid (ncid, 'Sky_FOV')


; Read supporting data:
       ncdf_diminq, ncid, ncdims(0),  dummy,   ncmaxrec
       ncdf_diminq, ncid, ncdims(1),  dummy,   ncnzones
       ncdf_diminq, ncid, ncdims(2),  dummy,   ncnchan
       ncdf_diminq, ncid, ncdims(3),  dummy,   ncnrings

       ncdf_varget, ncid, ncvars(0),  ncstime, offset=(0),          count=(1)
       ncdf_varget, ncid, ncvars(1),  ncetime, offset=(ncmaxrec-1), count=(1)
       ncdf_varget, ncid, ncvars(4),  ring_radii, offset=0, count=ncnrings
       ncdf_varget, ncid, ncvars(5),  sectors, offset=0, count=ncnrings
       ncdf_varget, ncid, ncvars(6),  plate_spacing, offset=0, count=1
       ncdf_varget, ncid, ncvars(7),  start_spacing, offset=0, count=1
       ncdf_varget, ncid, ncvars(8),  channel_spacing, offset=0, count=1
       ncdf_varget, ncid, ncvars(9),  scan_channels, offset=0, count=1
       ncdf_varget, ncid, ncvars(10), gap_refractive_Index, offset=0, count=1
       ncdf_varget, ncid, ncvars(11), sky_wavelength, offset=0, count=1
       ncdf_varget, ncid, ncvars(12), cal_wavelength, offset=0, count=1
       ncdf_varget, ncid, ncvars(12), cal_temperature, offset=0, count=1
       ncdf_varget, ncid, ncvars(14), sky_mass, offset=0, count=1
       ncdf_varget, ncid, ncvars(15), cal_mass, offset=0, count=1
       ncdf_varget, ncid, ncvars(16), sky_ref_finesse, offset=0, count=1
       ncdf_varget, ncid, ncvars(17), cal_ref_finesse, offset=0, count=1
       ncdf_varget, ncid, ncvars(18), sky_fov, offset=0, count=1
;       ncdf_attget, ncid, 'SiteCode', sitecode,  /GLOBAL
;       ncdf_attget, ncid, 'Start Day UT', ncdoy, /GLOBAL
;      Sky FOV has been logged incorrectly as 80 degrees. Fix.
       sky_fov = 72
       sectors = [sectors, 1]
       ring_radii = [ring_radii, ipd_pixels]
       
       ncdf_varget, ncid, ncdf_varid(ncid, 'Nm_Per_Step'), nmps, offset=0, count=1
       
       scan_gain = sky_wavelength /(2.*nmps*scan_channels)
       channel_spacing = nmps*scan_gain
       end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  This procedure checks if a variable is already defined in a netCDF
;  file and, if not, adds it to the file.

pro sdi_addvar, vname, dimids, units, byte=bt, char=ch, short=sh, $
                 long=lg, float=fl, double=db
@sdi_inc.pro
       newid = where(ncvars lt 0)
       newid = newid(0)
       lastvar = newid
       ncdf_control, ncid, /noverbose
       if (ncdf_varid(ncid, vname) ne -1) then begin
           ncvars(newid) = ncdf_varid (ncid, vname)
           return
       endif
       ncdf_control, ncid, /verbose
;       ncdf_control, ncid, /redef
       if (keyword_set(bt)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /byte)
       if (keyword_set(ch)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /char)
       if (keyword_set(sh)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /short)
       if (keyword_set(lg)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /long)
       if (keyword_set(fl)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /float)
       if (keyword_set(db)) then $
           ncvars(newid)  = ncdf_vardef(ncid, vname, dimids, /double)
       ncdf_attput, ncid, ncvars(newid), 'Units', units
;       ncdf_control, ncid, /endef
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  This procedure adds variables to the netCDF logfile to store the
;  results of peak fitting.  It only adds the variables if they do not
;  already exist.
;
pro sdi_add_fit_vars
@sdi_inc.pro
       sdi_addvar, 'Peak_Position',   [ncdims(1), ncdims(0)], $
                   'Scan Channels',   /float
       sdi_addvar, 'Peak_Width',      [ncdims(1), ncdims(0)], $
                   'Scan Channels',   /float
       sdi_addvar, 'Peak_Area',       [ncdims(1), ncdims(0)], $
                   'PMT Counts',      /float
       sdi_addvar, 'Background',      [ncdims(1), ncdims(0)], $
                   'PMT Counts per Channel',      /float
       sdi_addvar, 'Sigma_Position',  [ncdims(1), ncdims(0)], $
                   'Scan Channels',   /float
       sdi_addvar, 'Sigma_Width',     [ncdims(1), ncdims(0)], $
                   'Scan Channels',   /float
       sdi_addvar, 'Sigma_Area',      [ncdims(1), ncdims(0)], $
                   'PMT Counts',      /float
       sdi_addvar, 'Sigma_Bgnd',      [ncdims(1), ncdims(0)], $
                   'PMT Counts per Channel',      /float
       sdi_addvar, 'Chi_Squared',     [ncdims(1), ncdims(0)], $
                   'Dimensionless',   /float
       sdi_addvar, 'Signal_to_Noise', [ncdims(1), ncdims(0)], $
                   'Dimensionless',   /float
end

pro sdi_build_zonemap
@sdi_inc.pro
       print, 'Building Zone Map...'
       zone_centers= intarr(ncnzones, 3)
       sectors(0) = 1
       nzones=0
       edge  = mapix/2
       for xi=0,mapix-1 do begin
           x = xi - edge
           for yi=0,mapix-1 do begin
               y = yi - edge
               rsqrd  =  x*x + y*y
               if (x eq 0 and y eq 0) then angle = 0 $
                  else angle  = 180*atan(y, x)/3.14159
               if (angle lt 0) then angle = angle + 360
               ring   = 0
               zone   = 0
               while  ((rsqrd gt ((ring_radii(ring)/100.)*edge)^2) and $
                       (ring lt ncnrings)) do begin
                       zone = zone + sectors(ring)
                       ring = ring + 1
               endwhile
               sector = angle/(360./sectors(ring))
               zone   = zone + sector
               if (ring ge ncnrings) then zone = -1
               if (rsqrd gt edge^2) then zone = -1
               zone_map(xi, yi) = zone
               if (zone ge 0) then begin
                   zone_centers(zone, 0) = zone_centers(zone, 0) + xi
                   zone_centers(zone, 1) = zone_centers(zone, 1) + yi
                   zone_centers(zone, 2) = zone_centers(zone, 2) + 1
               endif
            endfor
       endfor
       nbad = 0
       bads = where(zone_centers(*,2) eq 0, nbad)
       if (nbad gt 0) then zone_centers(bads,2) = 1
       zone_centers(*, 0) = zone_centers(*, 0)/zone_centers(*, 2)
       zone_centers(*, 1) = zone_centers(*, 1)/zone_centers(*, 2)
       print, 'Zone Map Built.'
       if strupcase(getenv('rotate_images')) eq 'YES' then begin
          print, '### Notice: rotating zone map 180 degrees! ###'
          zone_map = rotate(zone_map(0:mapix-1, 0:mapix-1), 2)
          zone_centers(*,0) = (mapix - 1) - zone_centers(*,0)
          zone_centers(*,1) = (mapix - 1) - zone_centers(*,1)
       endif
       end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  This routine reads the times and spectral data corresponding to one
;  "exposure" of scanning Doppler imager data

pro sdi_read_exposure
@sdi_inc.pro
    spectra = intarr (ncnzones,ncnchan)
    ncdf_varget, ncid, ncvars(0), stime,   offset=[ncrecord], count=[1]
    ncdf_varget, ncid, ncvars(1), etime,   offset=[ncrecord], count=[1]
    ncdf_varget, ncid, ncvars(2), spectra, offset=[0,0,ncrecord], $
                 count=[ncnzones, ncnchan, 1]
    spectra = complex(spectra)
    end

pro sdi_read_fits
@sdi_inc.pro
    ncdf_varget, ncid, ncvars(0), stime,   offset=[ncrecord], count=[1]
    ncdf_varget, ncid, ncvars(1), etime,   offset=[ncrecord], count=[1]
    ncdf_varget, ncid, ncvars(lastvar),   sig2noise, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-1), chi_squared, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-6), backgrounds, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-7), areas, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-8), widths, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-9), positions, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-3), sigarea, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-4), sigwid, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(lastvar-5), sigpos, $
                 offset=[0, ncrecord], count=[ncnzones, 1]
    ncdf_varget, ncid, ncvars(2),   spectra, offset=[0,0,ncrecord], $
                 count=[ncnzones, ncnchan, 1]
    centime = stime/2 + etime/2
    areas = 300*areas/(etime - stime)
    badcount = 0
    bads = wherenan(sig2noise, badcount)
    if badcount gt 0 then sig2noise(bads) = 0.01
    end

pro sdi_append_fits
@sdi_inc.pro
         if (n_elements(posarr) eq 64) then begin
             posarr   = positions
             widarr   = widths
             britearr = areas
             basearr  = backgrounds
             sposarr  = sigpos
             swidarr  = sigwid
             sbritearr= sigarea
             aparr    = avpos
             awarr    = avwid
             abarr    = avarea
             chiarr   = chi_squared
             snrarr   = sig2noise
             timarr   = centime
         endif else begin
             posarr   = [[posarr], [positions]]
             widarr   = [[widarr], [widths]]
             britearr = [[britearr], [areas]]
             basearr  = [[basearr], [backgrounds]]
             sposarr  = [[sposarr], [sigpos]]
             swidarr  = [[swidarr], [sigwid]]
             sbritearr= [[sbritearr], [sigarea]]
             aparr    = [[aparr], [avpos]]
             abarr    = [[abarr], [avarea]]
             awarr    = [[awarr], [avwid]]
             chiarr   = [[chiarr], [chi_squared]]
             snrarr   = [[snrarr], [sig2noise]]
             timarr   = [[timarr],[centime]]
         endelse
end


pro sdi_zonal_averages
@sdi_inc.pro
         radwgt = fltarr(ncnzones)
         lims   = intarr(ncnrings)
         for rr=0,ncnrings-1 do lims(rr) = total(sectors(0:rr))
         for zz=1,ncnzones-1 do begin
             ringz  = where(lims gt zz)
             rng    = float(ringz(0))
;             radwgt(zz)  = (sectors(ringz(0)))
;             radwgt(zz)  = ringz(0) + 1
              phi         = !pi*sky_fov*rng/(ncnrings*180.)
              radwgt(zz)  = 4. + cos(phi)/(sin(phi))^2
         endfor
         radwgt(0)   = 20.*radwgt(1)
;         print, radwgt
         for rcd=0,ncrecord-2 do begin
             ng      = 0
             goods   = where(snrarr(*,rcd) gt 8, ng)
             if ng le 0 then goods   = indgen(ncnzones)
             wgt     = radwgt(goods)
             goods   = posarr(goods,rcd)
             worthy  = sort(goods)
             clipnum = 0.07*n_elements(worthy)
             worthy  = worthy(clipnum:n_elements(worthy)-clipnum-1)
             aparr(rcd) = total(goods(worthy)*wgt(worthy))/total(wgt(worthy))
             avwid   = median(widarr(0:ncnzones-1,rcd))
             avarea  = median(britearr(0:ncnzones-1,rcd))
         endfor
         end

pro poly_filter, xseries, yseries, order=nord, lowpass=lp
    nx   = n_elements(yseries)
    if not(keyword_set(nord ))    then nord  = 7

    xseries  = reform(xseries)
    yseries  = reform(yseries)
    xsave    = xseries
    ysave    = yseries
 
    yseries  = yseries(1:nx-2)
    nnx      = nx - 2
 
 yseries  = median([reverse(yseries), yseries, reverse(yseries)], 5)
    yseries  = yseries(nnx:nnx+nx-1)
    cfs      = polyfitw(dindgen(n_elements(yseries)), double(yseries), double(1./(0.5 + (yseries-median(yseries))^2)), 3, fy1)
    cfs      = polyfitw(dindgen(n_elements(yseries)), double(yseries), double(1./(0.5 + (yseries-median(yseries))^2)), 5, fy2)
    cfs      = polyfitw(dindgen(n_elements(yseries)), double(yseries), double(1./(0.5 + (yseries-median(yseries))^2)), nord, fy3)


    if not(keyword_set(lp)) then begin
    yseries = yseries - (fy1 + fy2 + fy3)/3.
 endif else begin
       yseries  = (fy1 + fy2 + fy3)/3.
 endelse
 return
end

; This procedure replaces the data in a low signal/noise zone with an
; an interpolated value:
pro sdi_interpolate_low_snr_zones, rcd, badzone=bz
@sdi_inc.pro
    if (not keyword_set(bz)) then bz = -1
            sep  = intarr(ncnzones, 2)
            zdst = fltarr(ncnzones)
            wgt  = fltarr(ncnzones)
            zlkp = bindgen(ncnzones)
            nbad = 0
            bads = where(snrarr(*,rcd) lt 12 or zlkp eq bz, nbad)
            if nbad gt 0 then begin
               for ix=0,n_elements(bads)-1 do begin
                   sep(*,0) = zone_centers(bads(ix),0) - zone_centers(*,0)
                   sep(*,1) = zone_centers(bads(ix),1) - zone_centers(*,1)
                   zdst(*)  = (sep(*,0)^2 + sep(*,1)^2)
                   zdst     = zdst^2
                   nuse     = 0
                   useful   = where(zdst gt 0 and snrarr(*,rcd) gt 32, nuse)
                   if (nuse gt 0) then begin
                       wgt(useful) = sqrt(500.+snrarr(useful, rcd))/zdst(useful)
                       posarr(bads(ix), rcd) = total(posarr(useful, rcd)*$
                                                     wgt(useful)) / $
                                               total(wgt(useful))
                       widarr(bads(ix), rcd) = total(widarr(useful, rcd)*$
                                                     wgt(useful)) / $
                                               total(wgt(useful))
                       britearr(bads(ix),rcd)= total(britearr(useful, rcd)*$
                                                     wgt(useful)) / $
                                               total(wgt(useful))
                   endif
               endfor
            endif
end

pro sdi_physical_units
@sdi_inc.pro

        c=2.997925e8
        amu=1.66053e-27
        bk=1.380658e-23
        f = 1e-6*c*channel_spacing / plate_spacing
        g = sky_mass*amu/(2*bk)
        if median(widarr) lt scan_channels then begin
           swidarr = g*(f*(widarr + swidarr))^2
           widarr = g*(f*widarr)^2
           swidarr = abs(swidarr - widarr)
        endif
        sposarr = f*sposarr
        for rcd=0,ncrecord-2 do begin
            posarr(*,rcd) = f*(posarr(*,rcd) - aparr(rcd))
            sdi_interpolate_low_snr_zones, rcd
        endfor
        end


pro sdi_remove_radial_residual, lorec=lr, hirec=hr, internal=itl
@sdi_inc.pro

        if (not keyword_set(lr)) then lr = 0
        if (not keyword_set(hr)) then hr = ncrecord-2
        rec1   = 0
        rec2   = ncrecord-2
        if (keyword_set(itl)) then begin
                 rec1 = lr
                 rec2 = hr
        endif
        radres = fltarr(ncnrings)
        lims   = intarr(ncnrings)
        nsum   = intarr(ncnrings)
        ridx   = intarr(ncnzones)
        zres   = intarr(ncnzones)
        intres = fltarr(ncnzones)
        brtres = fltarr(ncnzones)
goto, no_rr

;       Build an array specifying ring numbers for each zone:
        for rr=0,ncnrings-1 do lims(rr) = total(sectors(0:rr))
        for zz=0,ncnzones-1 do begin
            ringz  = where(lims gt zz)
            ridx(zz) = ringz(0)
        endfor

;       Compute average shift in each ring:
        for rr=0,ncnrings-1 do begin
            rzz    = where(ridx eq rr)
            radres(rr) = median(posarr(rzz, lr:hr))
            intres(rr) = median(britearr(rzz,lr:hr))
        endfor

;       Assign a residual value for each zone from the values for each ring:
        for zz=0,ncnzones-1 do begin
            zres(zz) = radres(ridx(zz))
            brtres(zz) = intres(ridx(zz))
        endfor

;       Normalize the brightness residual:
        mostbrite = max(brtres)
        if mostbrite eq 0. then mostbrite = 1.
        brtres = brtres/mostbrite + 1./200.

;       Subtract the residual map:
        for rcd=rec1,rec2 do begin
            posarr(*,rcd) = posarr(*,rcd) - zres
        endfor
;       Scale the brightnesses:
        for rcd=rec1,rec2 do begin
            britearr(*,rcd) = britearr(*,rcd)/brtres
        endfor
  
;       Remove any DC offset introduced to individual maps by the subtraction:
        sdi_zonal_averages
        for rcd=rec1,rec2 do begin
            posarr(*,rcd) = (posarr(*,rcd) - aparr(rcd))
        endfor

;return
;       We can now assume that any remaining radial residual is due to
;       vertical wind over the entire FOV.  First, calculate the time-
;       varying radial residual:

no_rr:

         
;        xres = posarr
;        for rcd=rec1,rec2 do begin
;            radres = fltarr(ncnrings)
;            nsum   = intarr(ncnrings)
;            for zz=0,ncnzones-1 do begin
;                radres(ridx(zz)) = radres(ridx(zz)) + posarr(zz,rcd)
;                nsum(ridx(zz)) =   nsum(ridx(zz)) + 1
;            endfor
;            radres = radres/nsum
;            for zz=0,ncnzones-1 do begin
;                xres(zz,rcd) = radres(ridx(zz))
;            endfor
;        endfor
;       Now smooth it in time:
;        for zz=0,ncnzones-1 do begin
;            xres(zz,*) = smooth(xres(zz,*), 5)
;        endfor
;       Now subtract it from the observations:
;        for rcd=rec1,rec2 do begin
;            posarr(*,rcd) = posarr(*,rcd) - xres(*,rcd)
;        endfor
;
        xres   = fltarr(ncnzones)
        radres = fltarr(ncnrings)
        for rcd=rec1,rec2 do begin
            for rr=1,ncnrings-1 do begin
                rad        = (ring_radii(rr) + ring_radii(rr-1))/2.
                ang        = rad*(sky_fov/100.)*!pi/180
                radres(rr) = cos(ang)*posarr(0,rcd)
            endfor
            for zz=1,ncnzones-1 do begin
                xres(zz) = radres(ridx(zz))
            endfor
;           Now subtract it from the observations:
            posarr(*,rcd) = posarr(*,rcd) - xres
        endfor
        end

pro sdi_map_zoneseps, sepmap
@sdi_inc.pro
       sepmap = fltarr(ncnzones, ncnzones)
       for i=0,ncnzones-1 do begin
           xsep = long(zone_centers(*, 0) - zone_centers(i, 0))
           ysep = long(zone_centers(*, 1) - zone_centers(i, 1))
           sepmap(*, i) = float(sqrt(xsep^2 + ysep^2))/mapix
       endfor
       end

function where_reasonable, wot, n_sigma
@sdi_inc.pro
    goodcount = 0
    goods = where(finite(wot(*)), goodcount)
    if goodcount le 0 then return, -1
    wotok = wot(goods)
    okidx = indgen(n_elements(goods))
    for j=0,goodcount-1 do begin
        nothers = 0
        others = where(okidx ne j, nothers)
        if nothers gt 2 then begin
           wotsam = wotok(others)
           sigma = sqrt((total(wotsam^2) - ((total(wotsam))^2) $
                       /(goodcount-1))/(goodcount-2))
           middle= median(wotsam)
        endif else begin
              sigma = 9e9
              middle = median(wotok)
        endelse
        if (abs(wotok(j) - middle))/sigma gt n_sigma then goods(j) = -1
     endfor
     goods = goods(where(goods ge 0))
     return, goods
end

pro sdi_diff_oper, inarr, outarr
    outarr = inarr
    nx = n_elements(inarr)-1
    if nx lt 1 then return
    out0   = inarr(1)  - inarr(0)
    outnx  = inarr(nx) - inarr(nx-1)
    if nx gt 1 then outarr = (shift(inarr, -1) - shift(inarr, 1))/2
    outarr(0)  = out0
    outarr(nx) = outnx
end

;===================================================================================
;  This procedure fits a 2-D wind field to the LOS data:

pro sdi_uniform_wind, dvdx_zero=dvdx_zero, fitpars=fitpars
@sdi_inc.pro
  ulosarr  = posarr
  uperparr = posarr
  wradarr  = posarr
  zonal    = posarr
  merid    = posarr
  fitpars  = {u: 0., v: 0., dudx: 0., dudy: 0., dvdx: 0., dvdy: 0.}
  fitpars  = replicate(fitpars, ncrecord)


  split_rings = 0

; Calculate the zone angular radius and bearing values analytically:
       rad   = fltarr(ncnzones)
       theta = fltarr(ncnzones)
       ridx  = bytarr(ncnzones)
       sidx  = ridx
       rcnt  = 0
       resarr= fltarr(ncnzones)
       for j=1,ncnzones-1 do begin
           rcnt = rcnt + 1
           ridx(j) = ridx(j-1)
           sidx(j) = sidx(j-1) + 1
           if rcnt eq sectors(ridx(j-1)) then begin
              ridx(j) = ridx(j-1) + 1
              sidx(j) = 0
              rcnt = 0
           endif
           if ridx(j) eq 0 then begin
              rad(j) = 0
              theta(j) = 0
           endif else begin
              rad(j)   = (ring_radii(ridx(j)) + ring_radii(ridx(j)-1))/2
              theta(j) = (sidx(j) + 0.5)*360/sectors(ridx(j))
           endelse
       endfor
       rad   = (rad*sky_fov/100)*!pi/180
       theta = theta*!pi/180

       fouriers = fltarr(ncrecord, ncnrings, 3, 2)
       for rcd=0,ncrecord-2 do begin
           ng      = 0
           goods   = where(snrarr(*,rcd) gt -1, ng)
           if ng le 0 then goods   = indgen(ncnzones)

; Compute the m=0, m=1, and m=2 components of Fourier decomposition:
           wgt = fltarr(ncnzones)
           wgt(goods) = 1
           totwgt = fltarr(ncnrings)

;          Accumulate the Fourier summations:
           for j=1,ncnzones-1 do begin
               fouriers(rcd, ridx(j), 0, 0) = fouriers(rcd, ridx(j), 0, 0) + $
                        posarr(j,rcd)*wgt(j)/sin(rad(j))
               fouriers(rcd, ridx(j), 1, 0) = fouriers(rcd, ridx(j), 1, 0) + $
                        posarr(j,rcd)*cos(theta(j))*wgt(j)/sin(rad(j))
               fouriers(rcd, ridx(j), 1, 1) = fouriers(rcd, ridx(j), 1, 1) + $
                        posarr(j,rcd)*sin(theta(j))*wgt(j)/sin(rad(j))
               fouriers(rcd, ridx(j), 2, 0) = fouriers(rcd, ridx(j), 2, 0) + $
                        posarr(j,rcd)*cos(2.*theta(j))*wgt(j)/sin(rad(j))
               fouriers(rcd, ridx(j), 2, 1) = fouriers(rcd, ridx(j), 2, 1) + $
                        posarr(j,rcd)*sin(2.*theta(j))*wgt(j)/sin(rad(j))
               totwgt(ridx(j)) = totwgt(ridx(j)) + wgt(j)
           endfor

;          Compute the Fourier coefficients:
           for rng=1,ncnrings-1 do begin
               if totwgt(rng) ne 0 then begin
                  fouriers(rcd, rng, *, 0) = fouriers(rcd, rng, *, 0) / $
                                             totwgt(rng)
                  fouriers(rcd, rng, *, 1) = fouriers(rcd, rng, *, 1) / $
                                             totwgt(rng)
               endif else begin
                  fouriers(rcd, rng, *, 0) = 1e-6
                  fouriers(rcd, rng, *, 1) = 1e-6
               endelse
               fouriers(rcd, rng, 0, 0) = fouriers(rcd, rng, *, 0)*2
               fouriers(rcd, rng, 0, 1) = fouriers(rcd, rng, *, 1)*2
           endfor
       endfor

;      Compute the meridional wind gradient with longitude, using
;      local time as a dimension proxy:
       mgrad = fltarr(ncrecord, rng)
       nx = ncrecord-1
       for rng=1,ncnrings-1 do begin
           mgrad(*, rng) = fouriers(*, rng, 1, 1)
           mgrad(nx,rng) = mgrad(nx-1,rng)
       endfor
       for rng=1,ncnrings-1 do begin
           mgrad(*,rng) = smooth(mgrad(*,rng), 5)
       endfor
       src_hgt = 240000
       maglat = 65*!pi/180.
       earthrad = 6371e3
       rotspeed = 2*!pi*cos(maglat)*earthrad/86400.
       sdi_diff_oper, timarr, deltime
       for rng=1,ncnrings-1 do begin
           sdi_diff_oper, mgrad(*,rng), mg
           mgrad(*,rng) = smooth(mg, 3)
           mgrad(*,rng) = -mgrad(*,rng)/(deltime(0:ncrecord-1)*rotspeed)
       endfor
       if keyword_set(dvdx_zero) then mgrad = fltarr(ncrecord, rng)
       
       imgrad = fltarr(ncrecord, rng) 

;      Compute the partial derivatives of zonal and meridional wind with
;      respect to x and y displacement from the zenith.  We start at rng=2,
;      since the central and first ring out only have 1 and 4 sectors
;      respectively, not enough to allow partial derivatives to be evaluated:
       dvdx = fltarr(ncrecord, ncnrings)
       dudy = fltarr(ncrecord, ncnrings)
       dvdy = fltarr(ncrecord, ncnrings)
       dudx = fltarr(ncrecord, ncnrings)
       for rng=2,ncnrings-1 do begin
           zang = (ring_radii(rng) + ring_radii(rng-1))/2
           zang = (zang*sky_fov/100)*!pi/180
           hdis = src_hgt*tan(zang)
           dvdx(*, rng) = mgrad(*, rng)
           dudy(*, rng) = (-2*fouriers(*, rng, 2, 1) - hdis*dvdx(*, rng))/hdis
           dvdy(*, rng) = (fouriers(*, rng, 0 ,0)-fouriers(*, rng, 2, 0))/hdis
           dudx(*, rng) = (fouriers(*, rng, 0 ,0)-fouriers(*, rng, 2, 0))/hdis
       endfor

;      Since we are using a first-order Taylor series expansion of the wind
;      about the zenith, it probably makes no sense to compute separate
;      partial derivatives in each ring.  Thus, unless "split_rings=1",
;      we replace each partial derivatives in each ring with the average
;      of that partial derivative over all rings:
       if not(split_rings) then begin
          for rcd=0,ncrecord-1 do begin
              dvdx(rcd, *) = -total(dvdx(rcd, 2:*))/(ncnrings-2)
              dudy(rcd, *) = -total(dudy(rcd, 2:*))/(ncnrings-2)
              dvdy(rcd, *) = -total(dvdy(rcd, 2:*))/(ncnrings-2)
              dudx(rcd, *) = -total(dudx(rcd, 2:*))/(ncnrings-2)
          endfor
       endif
;      Compute the first-order Taylor series zonal and meridional winds, and
;      then the component perpendicuar to the LOS:
       for rcd=0,ncrecord-1 do begin
           for zidx=1,ncnzones-1 do begin
               rng = ridx(zidx)
               xx  = src_hgt*tan(rad(zidx))*cos(theta(zidx))
               yy  = src_hgt*tan(rad(zidx))*sin(theta(zidx))
;              First, compute the fitted zonal and meridional winds:
               zonal(zidx, rcd)  = (fouriers(rcd, rng, 1, 0) + $
                                    dudx(rcd, rng)*xx + $
                                    dudy(rcd, rng)*yy)
               merid(zidx, rcd)  = (fouriers(rcd, rng, 1, 1) + $
                                    dvdx(rcd, rng)*xx + $
                                    dvdy(rcd, rng)*yy)
; the following 4 lines, commented out, were for diagnostics:
;               zonal(zidx, rcd)  = (dudx(rcd, rng)*xx + $
;                                    dudy(rcd, rng)*yy)
;               merid(zidx, rcd)  = (dvdx(rcd, rng)*xx + $
;                                    dvdy(rcd, rng)*yy)
;              Now resolve these into LOS and perpendicular winds:
               uperparr(zidx,rcd)= zonal(zidx, rcd)*sin(theta(zidx)) - $
                                   merid(zidx, rcd)*cos(theta(zidx))
               ulosarr(zidx,rcd) = zonal(zidx, rcd)*cos(theta(zidx)) + $
                                   merid(zidx, rcd)*sin(theta(zidx))
;              Finally, recompute zonal and meridional components from the
;              observed LOS and fitted perpendicular components:
               wradarr(zidx,rcd) = posarr(zidx, rcd)/sin(rad(zidx))
               zonal(zidx, rcd)  = wradarr(zidx, rcd)*cos(theta(zidx)) + $
                                   uperparr(zidx, rcd)*sin(theta(zidx))
               merid(zidx, rcd)  = wradarr(zidx, rcd)*sin(theta(zidx)) - $
                                   uperparr(zidx, rcd)*cos(theta(zidx))
           endfor
;          Compute the zonal and meridional winds at the zenith:
           zonal(0, rcd) = total(zonal(1:*, rcd))/(ncnzones-1)
           merid(0, rcd) = total(merid(1:*, rcd))/(ncnzones-1)
       endfor
end

pro sdi_ut_index
@sdi_inc.pro
       for rcd=0,n_elements(timarr)-1 do begin
           sec70cvt, timarr(rcd), yr, mo, dy, hr, mn, sc
           utsec = sc + 60*mn + 3600*hr
           utixarr(rcd) = fix(utsec/900)
       endfor
end

pro sdi_build_zonemap
@sdi_inc.pro
       zone_centers= intarr(ncnzones, 3)
       sectors(0) = 1
       nzones=0
       edge  = mapix/2
       for xi=0,mapix-1 do begin
           x = xi - edge
           for yi=0,mapix-1 do begin
               y = yi - edge
               rsqrd  =  x*x + y*y
               if (x eq 0 and y eq 0) then angle = 0 $
                  else angle  = 180*atan(y, x)/3.14159
               if (angle lt 0) then angle = angle + 360
               ring   = 0
               zone   = 0
               while  ((rsqrd gt ((ring_radii(ring)/100.)*edge)^2) and $
                       (ring lt ncnrings)) do begin
                       zone = zone + sectors(ring)
                       ring = ring + 1
               endwhile
               sector = angle/(360./sectors(ring))
               zone   = zone + sector
               if (ring ge ncnrings) then zone = -1
               if (rsqrd gt edge^2) then zone = -1
               zone_map(xi, yi) = zone
               if (zone ge 0) then begin
                   zone_centers(zone, 0) = zone_centers(zone, 0) + xi
                   zone_centers(zone, 1) = zone_centers(zone, 1) + yi
                   zone_centers(zone, 2) = zone_centers(zone, 2) + 1
               endif
            endfor
       endfor
       nbad = 0
       bads = where(zone_centers(*,2) eq 0, nbad)
       if (nbad gt 0) then zone_centers(bads,2) = 1
       zone_centers(*, 0) = zone_centers(*, 0)/zone_centers(*, 2)
       zone_centers(*, 1) = zone_centers(*, 1)/zone_centers(*, 2)
       if strupcase(getenv('rotate_images')) eq 'YES' then begin
          print, '### Notice: rotating zone map 180 degrees! ###'
          zone_map = rotate(zone_map(0:mapix-1, 0:mapix-1), 2)
          zone_centers(*,0) = (mapix - 1) - zone_centers(*,0)
          zone_centers(*,1) = (mapix - 1) - zone_centers(*,1)
       endif
       end

pro sdi_spacesmooth_fits, wot, spacewin
@sdi_inc.pro
       if spacewin lt 0.05 then return
       sdi_map_zoneseps, sepmap
       weight = fltarr(ncnzones)
       for zidx = 0,ncnzones-1 do begin
           weight = (sepmap(*,zidx)/spacewin)^2
           weight = weight < 50
           weight = exp(-weight)
           for rcd=0,ncrecord-2 do begin
               goods = where_reasonable(wot(*, rcd), 4)
               if goods(0) ne -1 then begin
                  wot(zidx,rcd) =  total(wot(goods, rcd)*weight(goods)) /$
                                   total(weight(goods))
               endif
           endfor
     wait, 0.05
       endfor
       end

pro sdi_timesmooth_fits,  wot, timewin
@sdi_inc.pro
       if timewin lt 0.1 then return
       for rcd=0,ncrecord-2 do begin
           weight = findgen(ncrecord) - rcd
           weight = (weight/timewin)^2
           weight = weight < 50
           weight = exp(-weight)
           for zidx=0,ncnzones-1 do begin
               goods = where_reasonable(wot(zidx,*), 4)
               if goods(0) ne -1 then begin
                  wot(zidx,rcd) =  total(wot(zidx,goods)*weight(goods)) /$
                                   total(weight(goods))
               endif
           end
     wait, 0.05
       endfor
       end


