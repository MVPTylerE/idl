; >>>> begin comments
;==========================================================================================
;
; >>>> McObject Class: sdi2k_math_spekfitz
;
; This file contains the McObject method code for sdi2k_math_spekfitz objects:
;
; Mark Conde Fairbanks, October 2000.
;
; >>>> end comments
; >>>> begin declarations
;         menu_name = Spectrum Fitter
;        class_name = sdi2k_math_spekfitz
;       description = SDI Analysis - Fit Spectra
;           purpose = SDI analysis
;       idl_version = 5.2
;  operating_system = Windows NT4.0 terminal server 
;            author = Mark Conde
; >>>> end declarations

@sdi2k_ncdf.pro

;==========================================================================================
; This is the (required) "new" method for this McObject:

pro sdi2k_math_spekfitz_new, instance, dynamic=dyn, creator=cmd
;---First, properties specific to this object:
    cmd = 'instance = {sdi2k_math_spekfitz, '
    cmd = cmd + 'specific_cleanup: ''sdi2k_math_spekfitz_specific_cleanup'', '    
    fitting = {fitting, prompt_for_filename: 1, $
                              skip_old_fits: 0, $
                         exit_on_completion: 0, $
                          menu_configurable: 1, $
                              user_editable: [0,1,2]} 
    cmd = cmd + 'fitting: fitting, '
;---Now add fields common to all SDI objects. These will be grouped as sub-structures:
    sdi2k_common_fields, cmd, automation=automation, geometry=geometry
;---Next, add the required fields, whose specifications are read from the 'declarations'
;   section of the comments at the top of this file:
    whoami, dir, file    
    obj_reqfields, dir+file, cmd, dynamic=dyn
;---Now, create the instance:
    status = execute(cmd)
end

;==========================================================================================
; This is the event handler for events generated by the sdi2k_math_spekfitz object:
pro sdi2k_math_spekfitz_event, event
    widget_control, event.top, get_uvalue=info
    wid_pool, 'Settings: ' + info.wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=spekfitz_settings
    if widget_info(event.id, /valid_id) and spekfitz_settings.automation.show_on_refresh then widget_control, event.id, /show

;---Check for a timer tick:    
    if tag_names(event, /structure_name) eq 'WIDGET_TIMER' then begin
       sdi2k_math_spekfitz_tik, info.wtitle
       if spekfitz_settings.automation.timer_ticking then widget_control, widx, timer=spekfitz_settings.automation.timer_interval
       return
    endif
    
;---Get the menu name for this event:
    widget_control, event.id, get_uvalue=menu_item
    if n_elements(menu_item) eq 0 then menu_item = 'Nothing valid was selected'
end

;==========================================================================================
; This is the routine that handles timer ticks:
pro sdi2k_math_spekfitz_tik, wtitle, redraw=redraw, _extra=_extra
@sdi2kinc.pro
end

pro sdi2k_math_spekfitz_plot, zidx, ospec, ispec, fitpars, quality, cal, instance, no_insprof=noinsp
@sdi2kinc.pro
;---Get settings information for this instance of the output xwindow and this instance of 
;   the plot program itself:
    widx = instance.id
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=info
    wid_pool, 'Settings: ' + instance.description, sidx, /get
    if not(widget_info(sidx, /valid_id)) then return
    widget_control, sidx, get_uvalue=spekfitz_settings

    if n_elements(zone_canvas) eq 0 then return

;---Now plot the current spectra:
    xtwk = 0.22/host.operation.zones.fov_rings
    ytwk = 0.18/host.operation.zones.fov_rings
    edge = [0.5, 0.5]
    j=zidx
    lolef = [1.05*zone_centers(j, 0) - xtwk, zone_centers(j, 1) - ytwk] + edge
    uprgt = [1.05*zone_centers(j, 0) + xtwk, zone_centers(j, 1) + ytwk] + edge
    cell  = [lolef(0:1), uprgt(0:1)] 
    !p.position =  cell
    xz    = host.hardware.etalon.scan_channels/2
    yz    = 0
    y1    = max(spectra(j,*))
;    ifun  = min(ospec) + (ispec-min(ispec))*fitpars(2)/(max(ispec)-min(ispec))
    ifun  = min(ospec) + (ispec-min(ispec))*(max(ospec)-min(ospec))/(max(ispec)-min(ispec))
    if keyword_set(noinsp) then begin
	   plot, ifun, color=host.colors.white, xstyle=5, ystyle=5, /noerase, $
	         yrange=[min(ospec), max(ospec)], /nodata
    endif else begin
	   plot, ifun, color=host.colors.white, xstyle=5, ystyle=5, /noerase, $
	         yrange=[min(ospec), max(ospec)]
	endelse
    oplot,quality.fitfunc, color=host.colors.purple, thick=2
    oplot,ospec, color=host.colors.white, psym=1, symsize=0.25
    axis, xaxis=0, xstyle=1, color=greymax, xticklen=.07, $
          xtickv = [0,31,63,95,127], xticks = 4, $
          xtickname = [' ',' ',' ',' ',' ']
    !p.position =  0

;---Check if we need to make a GIF file:
    ;sdi2k_plugin_gif, info, js_time=timlimz(1)
end

;==========================================================================================
;   Cleanup jobs:
pro sdi2k_math_spekfitz_specific_cleanup, widid
@sdi2kinc.pro
end

;========================================================================
;  This routine scans the data file for fit results, looking for the
;  first record with a Chi-Squared value equal to the "no data" fill
;  value for the netCDF file.  This is presumed to be the first record
;  for which fitting needs to be done.  That is, calling this routine
;  will skip all existing fits.
pro sdi2k_skip_existing_fits, ncid, record
@sdi2kinc.pro
    record = -1
    nz = total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1))
    repeat begin
           record = record + 1
           ncdf_varget, ncid, ncdf_varid(ncid, 'Chi_Squared'), chisq, offset=[0, record], count=[nz, 1]
           nf = 0
           fitted = 0
           badz = where(not(finite(chisq)), nf)
           if nf ne 0 then fitted = max(chisq) ne min(chisq)
           wait, 0.01
    endrep until (not(fitted))
end

;========================================================================
;  This is procedure fits position, width, area and background
;  parameters to an exposure of sdi spectra:

pro sdi2k_fit_spectra, ncid, record, sig2noise, chi_squared, $
                       sigarea, sigwid, sigpos, sigbgnd, $
                       backgrounds, areas, widths, positions, insprofs, instance, initial_temp=itmp, $
                       no_temperature=notemp, min_iters=min_iters, shiftpos=shiftpos
@sdi2kinc.pro
    widx = instance.id
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=info
    wid_pool, 'Settings: ' + instance.description, sidx, /get
    if not(widget_info(sidx, /valid_id)) then return
    widget_control, sidx, get_uvalue=spekfitz_settings

    if !d.name ne 'Z' and !d.name ne 'PS' then wset, info.wid
    
;---Display the zone map as a background for the spectra plots:
    tv, zone_canvas
    xyouts, 0.05, 0.95, 'Exposure: ' + strcompress(string(record)), $
            align=0, /normal, color=host.colors.white, charthick=3, charsize=2
    xyouts, 0.95, 0.95, 'Scans: ' + strcompress(string(1+host.programs.spectra.etalon_scans)), $
            align=1, /normal, color=host.colors.white, charthick=3, charsize=2
            
    tstrt = dt_tm_mk(js2jd(0d)+1, host.programs.spectra.start_time, format='0d$ n$ Y$, h$:m$')            
    xyouts, 0.03, 0.03, tstrt, $
            align=0, /normal, color=host.colors.white, charthick=3, charsize=2
    tend  = dt_tm_mk(js2jd(0d)+1, host.programs.spectra.start_time + $
                                  host.programs.spectra.integration_seconds, format='0d$ n$ Y$, h$:m$')            
    xyouts, 0.98, 0.03, tend, $
            align=1, /normal, color=host.colors.white, charthick=3, charsize=2


        if (total(abs(spectra)) lt 100) then return

        print,  'Rec', ' Zn',  ' Sig/Nse', 'Iters  ', 'ChiSq', $
                'Position/Err', 'Width/Err', 'Area/Err',  'Bgnd/Err',   $
                 format='(a3,a3,a8,a9,a7,a18,a18,a15,a20)'

;-------Specify the diagnostics that we'd like:
        diagz = ['dummy']
        diagz = [diagz, 'main_loop_wait(ctlz.secwait = 0.001)']
;        diagz = [diagz, 'main_plot_fitz(window, 1)']
;        diagz    = [diagz, 'main_plot_answer(window, 0)']

;-------Describe the species:
        species = {s_spec, name: 'O', $
                           mass:  15.99491, $
                         relint: 1.}
;-------Describe the instrument.
        dellam  = ((host.operation.calibration.sky_wavelength*1e-9)^2)/(2*(host.hardware.etalon.gap*1e-3)*1.000276*host.hardware.etalon.scan_channels)
        cal     = {s_cal,   delta_lambda: dellam, $
                          nominal_lambda: host.operation.calibration.sky_wavelength*1e-9}
        fix_mask= [0,  1,  0,  0,  0]
		if keyword_set(notemp) then fix_mask= [0,  1,  0,  0,  1]

        nz = total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1))
        sig2noise   = fltarr(nz)
        chi_squared = fltarr(nz)
        positions   = fltarr(nz)
        widths      = fltarr(nz)
        areas       = fltarr(nz)
        backgrounds = fltarr(nz)
        sigpos      = fltarr(nz)
        sigwid      = fltarr(nz)
        sigarea     = fltarr(nz)
        sigbgnd     = fltarr(nz)
        
        for zidx=0,nz-1 do begin
            fitpars = [0., 0., 0., 0., 1000.]
            if keyword_set(itmp) then fitpars(4) = itmp
;-----------Fit the spectra:
   		    if keyword_set(notemp) then fitpars(4) = 2.
            spx = reform(spectra(zidx,*))
            if keyword_set(shiftpos) then spx = shift(spx, shiftpos)
            ipr = reform(insprofs(zidx,*))
            spk = where(mc_im_sm(spx, 5) eq max(mc_im_sm(spx, 5)))
            ipk = where(mc_im_sm(ipr, 3) eq max(mc_im_sm(ipr, 3)))
            fitpars(3) = spk(0) - ipk(0)
            spek_fit, spx, ipr, $
                      species, cal, fix_mask, diagz, fitpars, sigpars, quality, /passive, max_iters=200, min_iters=min_iters                    
            if quality.iters gt 0 then chisq = quality.chisq(quality.iters-1)/quality.df

;-----------Weed out "NaN"s (Not-A-Number) from the results
            nancount = 0
            bads     = where(finite(fitpars) lt 1, nancount)
            if (nancount ne 0)      or $
               (finite(chisq) lt 1) or $
               (quality.status eq 'Signal/noise too low') or $
               (quality.status eq 'Singular dimensions encountered') then begin
                               fitpars = [-1., -1., -1., -1., -1.]
                               chisq = 9e9
                               quality.snr   = 0
            endif

;-----------Plot the fit result:
            sdi2k_math_spekfitz_plot, zidx, spx, reform(insprofs(zidx,*)), $
                  fitpars, quality, cal, instance, no_insprof = notemp
            wait, 0.1

            sig2noise(zidx)   = quality.snr
            chi_squared(zidx) = chisq
            positions(zidx)   = fitpars(3)
            widths(zidx)      = fitpars(4)
            areas(zidx)       = fitpars(2)
            backgrounds(zidx) = fitpars(0)
            sigpos(zidx)      = sigpars(3)
            sigwid(zidx)      = sigpars(4)
            sigarea(zidx)     = sigpars(2)
            sigbgnd(zidx)     = sigpars(0)

            if (sig2noise(zidx) lt 100000) then $
                snrstr = string(long(sig2noise(zidx)), format='(i7)') $
            else $
                snrstr = string(sig2noise(zidx),      format='(g7.0)')

            kounts = string(quality.iters, format='(i5)')
            kounts = strcompress(kounts, /remove_all)
            posstr = string(positions(zidx), '/', sigpos(zidx), $
                            format='(f7.2, a1, f6.2)')
            posstr = strcompress(posstr, /remove_all)
            widstr = string(widths(zidx), '/', sigwid(zidx), $
                            format='(f7.2, a1, f6.2)')
            widstr = strcompress(widstr, /remove_all)
            arastr = string(areas(zidx), '/', sigarea(zidx), $
                            format='(f8.1, a1, f6.1)')
            arastr = strcompress(arastr, /remove_all)
            bgstr  = string(backgrounds(zidx), '/', sigbgnd(zidx), $
                            format='(f9.1, a1, f8.2)')
            bgstr  = strcompress(bgstr, /remove_all)

            print,  record, zidx, snrstr, kounts, chisq, $
                    posstr, widstr, arastr, bgstr, ' -> ', quality.status, $
            format='(i3,i3,a8,a7,f9.2,a18,a18,a15,a20, a4, a)'

        endfor
end

pro sdi2k_fix_spekwrap
@sdi2kinc.pro
        nz = total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1))
        nb = 0
        for zidx=0,nz-1 do begin
            itz = 0
            while (max(abs(spectra(zidx,*) - shift(spectra(zidx,*), -1))) gt 32768) and (itz lt 1000) do begin
               for j=1,n_elements(spectra(zidx,*))-1 do begin
                   dif = spectra(zidx,j) - spectra(zidx,j-1)
                   if dif gt 32768  then spectra(zidx,j) = spectra(zidx,j) - 65336
                   if dif lt -32768 then spectra(zidx,j) = spectra(zidx,j) + 65336
               endfor
               itz = itz + 1
               wait, 0.001
            endwhile
        endfor
end

;==========================================================================================
; This is the (required) "autorun" method for this McObject. If no autorun action is 
; needed, then this routine should simply exit with no action:

pro sdi2k_math_spekfitz_autorun, instance
@sdi2kinc.pro
    instance.geometry.xsize = 950
    instance.geometry.ysize = 950
    instance.automation.timer_interval = 1.
    instance.automation.timer_ticking = 0
    sdi2k_reset_spectra
    mnu_xwindow_autorun, instance, topname='sdi2ka_top'
    
    skyfile = sdi2k_filename('sky')
    insfile = sdi2k_filename('ins')
    if instance.fitting.prompt_for_filename then begin
       skyfile = dialog_pickfile(file=skyfile, $
                                 filter='sky' + '*.' + host.operation.header.site_code, $
                                 group=widx, title='Select a file of sky spectra: ', $
                                 path=host.operation.logging.log_directory)                                 
       insfile = dialog_pickfile(file=insfile, $
                                 filter='ins' + '*.' + host.operation.header.site_code, $
                                 group=widx, title='Select a file of insprofs: ', $
                                 path=host.operation.logging.log_directory)                                 
    endif
    sdi2k_load_insprofs, insfile, insprofs, insid, 1
	
;---Fit the instrument profiles, for drift tracking:
    instance.fitting.skip_old_fits = 0
    sdi2k_ncopen, insfile, ncid, 1
    sdi2k_build_zone_map, canvas_size = [950, 950]
    sdi2k_add_fitvars, ncid
    ncdf_diminq, ncid, ncdf_dimid(ncid, 'Time'),    dummy,  maxrec
    ncdf_diminq, ncid, ncdf_dimid(ncid, 'Channel'), dummy,  nchan
    record = 0
    if instance.fitting.skip_old_fits then sdi2k_skip_existing_fits, ncid, record
    mcchoice, 'Fit Instrument Profiles?', ['Yes', 'No'], choice
    if choice.name ne 'Yes' then goto, NO_IPR
    sdi2k_zenav_peakpos, ncid, cpos

    progressBar = Obj_New("SHOWPROGRESS", message='Percent Completion', title='Progress')
    progressBar->Start
    for rec=record,host.netcdf(1).ncmaxrec-1 do begin
        progressbar->update, 100.*rec/float(host.netcdf(1).ncmaxrec-1) 
        sdi2k_read_exposure, ncid, rec
;        sdi2k_fix_spekwrap
        sdi2k_fit_spectra,   ncid, rec, sig2noise, chi_squared, $
                                        sigarea, sigwid, sigpos, sigbgnd, $
                                        backgrounds, areas, widths, positions, insprofs, instance, /no_temperature, $
                                        min_iters=5, shiftpos = nchan/2 - cpos
        sdi2k_write_fitpars, ncid, rec, sig2noise, chi_squared, $
                                        sigarea, sigwid, sigpos, sigbgnd, $
                                        backgrounds, areas, widths, positions
        wait, 0.002
    endfor
    progressBar->Destroy
    Obj_Destroy, progressBar

NO_IPR:
    ncdf_close, ncid
    host.netcdf(1).ncid = -1

;---Fit the sky profiles:
    instance.fitting.skip_old_fits = 0
    sdi2k_ncopen, skyfile, ncid, 0
    sdi2k_add_fitvars, ncid
    ncdf_diminq, ncid, ncdf_dimid(ncid, 'Time'),    dummy,  maxrec
    ncdf_diminq, ncid, ncdf_dimid(ncid, 'Channel'), dummy,  nchan
    
    progressBar = Obj_New("SHOWPROGRESS", message='Percent Completion', title='Progress')
    progressBar->Start

    record = 0
    itmp   = 1000.
    if instance.fitting.skip_old_fits then sdi2k_skip_existing_fits, ncid, record
    sdi2k_zenav_peakpos, ncid, cpos
    for rec=record,host.netcdf(0).ncmaxrec-1 do begin
        progressbar->update, 100.*rec/float(host.netcdf(0).ncmaxrec-1) 
        sdi2k_read_exposure, ncid, rec
;        sdi2k_fix_spekwrap
        sdi2k_fit_spectra,   ncid, rec, sig2noise, chi_squared, $
                                        sigarea, sigwid, sigpos, sigbgnd, $
                                        backgrounds, areas, widths, positions, insprofs, $
                                        instance, min_iters=16, shiftpos=nchan/2 - cpos, initial_temp=itmp
        sdi2k_write_fitpars, ncid, rec, sig2noise, chi_squared, $
                                        sigarea, sigwid, sigpos, sigbgnd, $
                                        backgrounds, areas, widths, positions
        itmp = median(widths)
        wait, 0.002
    endfor
    progressBar->Destroy
    Obj_Destroy, progressBar
    ncdf_close, ncid
    host.netcdf(0).ncid = -1

    if instance.fitting.exit_on_completion then wid_pool, instance.description, widx, /destroy
end

;==========================================================================================
; This is the (required) class method for creating a new instance of the sdi2k_math_spekfitz object. It
; would normally be an empty procedure.  Nevertheless, it MUST be present, as the last procedure in 
; the methods file, and it MUST have the same name as the methods file.  By calling this
; procedure, the caller forces all preceeding routines in the methods file to be compiled, 
; and so become available for subsequent use:

pro sdi2k_math_spekfitz
end

