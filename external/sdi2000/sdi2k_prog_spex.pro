; >>>> begin comments
;==========================================================================================
;
; >>>> McObject Class: sdi2k_prog_spex
;
; This file contains the McObject method code for sdi2k_prog_spex objects:
;
; Mark Conde (Mc), Fairbanks, September 2000.
;
; >>>> end comments
; >>>> begin declarations
;         menu_name = Acquire Spectra
;        class_name = sdi2k_prog_spex
;       description = SDI Program - Acquire Spectra
;           purpose = SDI operation
;       idl_version = 5.2
;  operating_system = Windows NT4.0 terminal server 
;            author = Mark Conde
; >>>> end declarations


;==========================================================================================
; This is the (required) "new" method for this McObject:

pro sdi2k_prog_spex_new, instance, dynamic=dyn, creator=cmd
;---First, properties specific to this object:
    cmd = 'instance = {sdi2k_prog_spex, '
    cmd = cmd + 'specific_cleanup: ''sdi2k_prog_spex_specific_cleanup'', '    
;---Now add fields common to all SDI objects. These will be grouped as sub-structures:
    sdi2k_common_fields, cmd, automation=automation, geometry=geometry
;---Next, add the required fields, whose specifications are read from the 'declarations'
;   section of the comments at the top of this file:
    whoami, dir, file    
    obj_reqfields, dir+file, cmd, dynamic=dyn
;---Now, create the instance:
    status = execute(cmd)
end

;==========================================================================================
; This is the event handler for events generated by the sdi2k_prog_spex object:
pro sdi2k_prog_spex_event, event
@sdi2kinc.pro
    widget_control, event.top, get_uvalue=info
    wid_pool, 'Settings: ' + info.wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=spex_settings
    if widget_info(event.id, /valid_id) and spex_settings.automation.show_on_refresh then widget_control, event.id, /show

;---Get the programmed stop time:
    if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'INS' then begin
       stoptime = host.operation.times.calibration_times(1)
    endif else begin
       stoptime = host.operation.times.observing_times(1)
    endelse
    
;---Check for a timer tick:    
    if tag_names(event, /structure_name) eq 'WIDGET_TIMER' then begin
       sdi2k_prog_spex_tik, info.wtitle
       if spex_settings.automation.timer_ticking then widget_control, widx, timer=spex_settings.automation.timer_interval
       return
    endif
    
;---Check for a new frame event sent by the control module:
    nm      = 0
    matched = where(tag_names(event) eq 'NAME', nm)
    if nm gt 0 then begin
       if event.(matched(0)) eq 'NewFrame' then begin
          sdi2k_prog_spex_tik, info.wtitle
          return
       endif
       if event.(matched(0)) eq 'Exposure Completed' then begin
          sdi2k_prog_spex_exposure_done, info.wtitle
;---------We put the test for stop time here, so that we will only stop at the end of an exposure:
          jsnow = dt_tm_tojs(systime())
          if jsnow gt stoptime then begin
             wid_pool, info.wtitle, self, /destroy
          endif
          return
       endif
    endif

;---Get the menu name for this event:
    widget_control, event.id, get_uvalue=menu_item
    if n_elements(menu_item) eq 0 then menu_item = 'Nothing valid was selected'
end

;==========================================================================================
; This is the routine that updates the actual plot:
pro sdi2k_prog_spex_tik, wtitle, redraw=redraw, _extra=_extra
@sdi2kinc.pro
    common spex_common, exposure_time, srate, viewstate, skycount, spex_discards

;---Get settings information for this instance of the output xwindow and this instance of 
;   the plot program itself:
    wid_pool, wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=info
    wid_pool, 'Settings: ' + wtitle, sidx, /get
    if not(widget_info(sidx, /valid_id)) then return
    widget_control, sidx, get_uvalue=spex_settings
    
;---This is a fix. Discard the first several frames at the start of each exposure:
    spex_discards = spex_discards + 1
    if spex_discards lt 25 then begin
       sdi2k_reset_spectra
       return
    endif

;---Next, get the etalon moved on to the next spacing, as the CCD has already started:
;   exposing the next frame, and we want the etalon scanned for it asap:
    scansave = fix(host.hardware.etalon.current_channel)
    if !d.name ne 'Z' and !d.name ne 'PS' then begin
       if strupcase(strcompress(viewstate, /remove_all)) eq 'SKY' then $
          lambda=host.operation.calibration.sky_wavelength else $
          lambda=host.operation.calibration.cal_wavelength
       wset, info.wid
       sdi2k_etalon_scan, lambda=lambda
;------Now update the spectra:
       nz = fix(total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1)))
       sizes = fix([n_elements(view(*,0)), n_elements(view(0,*)), nz, host.hardware.etalon.scan_channels])
       if n_elements(phase)    gt 0 and $
          n_elements(zone_map) gt 0 and $
          n_elements(spectra)  gt 0 then begin
          if strupcase(strcompress(viewstate, /remove_all)) eq 'SKY' then begin
             status = call_external(host.controller.behavior.dll_file, "UpdateSpectra", $
                                    view, phase, zone_map, spectra, scansave, sizes, value=bytarr(6), /cdecl)
          endif else begin
             status = call_external(host.controller.behavior.dll_file, "UpdateSpectra", $
                                    view, cal_phase, zone_map, spectra, scansave, sizes, value=bytarr(6), /cdecl)
          endelse
       endif
    endif

;---If we have just finished a scan, update the spectra, and check for end time:
    if (scansave eq host.hardware.etalon.scan_channels-1) or $
       (!d.name eq 'Z' or !d.name eq 'PS') then begin
       if !d.name ne 'Z' and !d.name ne 'PS' then $
          host.programs.spectra.etalon_scans = host.programs.spectra.etalon_scans + 1
;------Display the zone map as a background for the spectra plots:
       tv, zone_canvas
;------Now plot the current spectra:
       xtwk = 0.2/host.operation.zones.fov_rings
       ytwk = 0.15/host.operation.zones.fov_rings
       edge = [0.5, 0.5]
       nz = total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1))
       totsig = 0.
       
;------Get the number of records in the active log file:
       vid  = strupcase(strcompress(viewstate, /remove_all)) eq 'INS'
       ncid = host.netcdf(vid).ncid
       ncdf_diminq,  ncid, ncdf_dimid(ncid, 'Time'), dummy, maxrec
       host.operation.header.records = maxrec 
 
       for j=0,nz-1 do begin
           lolef = [zone_centers(j, 0) - xtwk, zone_centers(j, 1) - ytwk] + edge
           uprgt = [zone_centers(j, 0) + xtwk, zone_centers(j, 1) + ytwk] + edge
           cell  = [lolef(0:1), uprgt(0:1)] 
           !p.position =  cell
           xz    = host.hardware.etalon.scan_channels/2
           yz    = 0
           y1    = max(spectra(j,*))
           plot, spectra(j,*), color=host.colors.white, $
                 xstyle=5, ystyle=5, /noerase
           axis, xaxis=0, xstyle=1, color=greymax, xticklen=.07, $
                 xtickv = [0,31,63,95,127], xticks = 4, $
                 xtickname = [' ',' ',' ',' ',' ']
           oplot, [xz, xz], [yz, y1], color=host.colors.white
           totsig = totsig + total(spectra(j,*) - min(mc_im_sm(spectra(j,*), 8)))
       endfor
       !p.position =  0
       xyouts, 0.03, 0.95, 'Exposure: ' + strcompress(string(host.operation.header.records)), $
               align=0, /normal, color=host.colors.white, charthick=3, charsize=2
       xyouts, 0.97, 0.95, 'Scans: ' + strcompress(string(1+host.programs.spectra.etalon_scans)), $
               align=1, /normal, color=host.colors.white, charthick=3, charsize=2
       delsec= dt_tm_tojs(systime()) - host.programs.spectra.start_time
       frate = total(spectra)/(1e6*delsec)
       srate = totsig/(1e6*delsec)
       brate = frate - srate
       xyouts, 0.03, 0.03, strcompress(string(srate, format='(f8.2)') + ' +' + $
                                       string(brate, format='(f8.1)') + ' MHz'), $
               align=0, /normal, color=host.colors.white, charthick=3, charsize=2
               
       xyouts, 0.97, 0.08,  dt_tm_mk(js2jd(0d)+1,  host.programs.spectra.start_time, format='h$:m$:s$') + '!C' + $
                            dt_tm_mk(js2jd(0d)+1,  dt_tm_tojs(systime()),            format='h$:m$:s$') + '!C' + $
                            dt_tm_mk(js2jd(0d)+1,  host.programs.spectra.start_time, format='N$ 0d$'), $
               align=1, /normal, color=host.colors.white, charthick=3, charsize=2
       xyouts, 0.5, 0.05, 'N', align=0.5, /normal, color=host.colors.white, charthick=5, charsize=3
       xyouts, 0.5, 0.94, 'S', align=0.5, /normal, color=host.colors.white, charthick=5, charsize=3
       xyouts, 0.05, 0.5, 'W', align=0.5, /normal, color=host.colors.white, charthick=5, charsize=3
       xyouts, 0.95, 0.5, 'E', align=0.5, /normal, color=host.colors.white, charthick=5, charsize=3

;------Test for end of exposure. If integration_seconds is set negative, 
;      then we use an auto exposure calculation based on signal brightness (srate):
       exposure_time = host.programs.spectra.integration_seconds
       if host.programs.spectra.auto_exposure then begin
          maxsec = host.programs.spectra.max_integration_seconds
          minsec = host.programs.spectra.min_integration_seconds
          dropwidth = host.programs.spectra.integration_dropwidth
          exposure_time = maxsec - (maxsec - minsec)*(1. - exp(-srate/dropwidth))
       endif
       
      etest = exposure_time
      if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'SKY' and $
         strupcase(strcompress(viewstate, /remove_all)) eq 'INS' then etest = host.programs.spectra.calibration_exposure
  
       if dt_tm_tojs(systime()) - host.programs.spectra.start_time gt etest then begin
;---------Make a GIF of the final spectra (if gif-ing is active):
          if strupcase(strcompress(viewstate, /remove_all)) eq 'SKY' then sdi2k_plugin_gif, info, /now
          wid_pool, 'sdi2k_top', tidx, /get
          if !d.name ne 'Z' and !d.name ne 'PS' then $
              widget_control, sidx, send_event={id: tidx, $
                                               top: tidx, $
                                           handler: sidx, $
                                              name: 'Exposure Completed'}
       endif
    endif

;---Finally, update the exposure meter, if it exists:
    wid_pool, 'SDI Program - Exposure: Spectra', eidx, /get
    wid_pool, 'spectra_exposure_slider', slid, /get
    
    if not(widget_info(eidx, /valid_id)) then return
    if not(widget_info(sidx, /valid_id)) then return

    if n_elements(exposure_time) gt 0 then etest = exposure_time
    if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'SKY' and $
       strupcase(strcompress(viewstate, /remove_all)) eq 'INS' then etest = host.programs.spectra.calibration_exposure
    if n_elements(etest) eq 0 then etest = host.programs.spectra.integration_seconds

    delsecs = dt_tm_tojs(systime()) - host.programs.spectra.start_time
    pcnt    = 100.*delsecs/etest
    widget_control, slid, get_value=opc
    if abs(pcnt - opc) gt 2 then widget_control, slid, set_value=pcnt

    widget_control, sidx, set_uvalue=spex_settings
end

;==========================================================================================
;   End of phase map integration: save the phase map to a file, and exit:
pro sdi2k_prog_spex_exposure_done, wtitle
@sdi2kinc.pro
    common spex_common, exposure_time, srate, viewstate, skycount, spex_discards
    sdi2k_user_message, 'Completed ' + viewstate + ' exposure ' + $
                         strcompress(string(host.operation.header.records)) + $
                        '. Brightness: ' + strcompress(string(srate, format='(f8.2)') + ' MHz')
    sdi2k_spex_writespex, viewstate
    host.programs.spectra.start_time = dt_tm_tojs(systime())
    host.programs.spectra.etalon_scans = -1
    spex_discards = -200
    sdi2k_reset_spectra
    
;---If these are sky observations, check if we need to take a periodic 
;   set of laser calibration spectra:
    if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'SKY' then begin
       if strupcase(strcompress(viewstate, /remove_all)) eq 'INS' then begin
          viewstate = 'SKY'
          skycount  = 0
          sdi2k_set_shutters, laser='open', camera='open'
;          status = sdi2k_filter_interface(command='1 mv') ;was used when filter was behind shutter
          wait, 1.5
       endif else begin
          skycount = skycount + 1
          if skycount ge host.programs.spectra.calibration_frequency then begin
             viewstate = 'INS'
             skycount  = 0
;             status = sdi2k_filter_interface(command='4 mv') ;was used when filter was behind shutter
             sdi2k_set_shutters, laser='closed', camera='open'
             wait, 1.5
          endif 
       endelse
    endif
    sdi2k_reset_spectra
    host.hardware.etalon.start_spacing = 0
    host.programs.spectra.etalon_scans = -1
    sdi2k_etalon_scan, /reset
    spex_discards = 0
end

;==========================================================================================
;   Cleanup jobs:
pro sdi2k_prog_spex_specific_cleanup, widid
@sdi2kinc.pro
    host.controller.scheduler.job_semaphore = 'No scheduled job'
    sdi2k_set_shutters, camera='closed', laser='closed'
    sdi2k_ncdf_close
end

pro sdi2k_prog_spex_end_expmeter
@sdi2kinc.pro
    wid_pool, 'SDI Program - Exposure: Spectra', /destroy
end


;==========================================================================================
; This is the (required) "autorun" method for this McObject. If no autorun action is 
; needed, then this routine should simply exit with no action:

pro sdi2k_prog_spex_autorun, instance
@sdi2kinc.pro
    common spex_common, exposure_time, srate, viewstate, skycount, spex_discards
    zone = bytarr(n_elements(view(*,0)), n_elements(view(0,*)))
    instance.geometry.xsize = host.programs.spectra.window_xsize
    instance.geometry.ysize = host.programs.spectra.window_ysize
    instance.automation.timer_interval = 1.
    instance.automation.timer_ticking = 0
    instance.automation.auto_gif_interval = 9999999l
    viewstate = 'INS'
    skycount  = 0
    spex_discards = 0
;    status = sdi2k_filter_interface(command='1 mv') ; for 6300 ######
    status = sdi2k_filter_interface(command='2 mv') ; for 5577 ######
;    status = sdi2k_filter_interface(command='5 mv') ; for sodium
    
;---Load the phase and zone maps:
    if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'INS' then begin
       sdi2k_open_logging, 'ins'
       sdi2k_load_phase_map, sdi2k_filename('phc')
       cal_phase = phase
    endif else begin
       sdi2k_load_insprofs, sdi2k_filename('ins'), insprofs, insid, 1, norm=norm
       insbrite = norm
       sdi2k_open_logging, 'ins'
       sdi2k_open_logging, 'sky'
       sdi2k_load_phase_map, sdi2k_filename('phc')
       cal_phase = phase
       sdi2k_load_phase_map, sdi2k_filename('phs') 
    endelse

    phase = phase - host.programs.spectra.channel_shift
    sdi2k_build_zone_map
    sdi2k_set_shutters, camera='open', laser='closed' ; Always start with a laser calibration
    host.hardware.etalon.start_spacing = 0
    host.programs.spectra.etalon_scans = -1
    sdi2k_etalon_scan, /reset
    sdi2k_reset_spectra
    mnu_xwindow_autorun, instance, topname='sdi2k_top'
    
    host.controller.scheduler.job_semaphore = 'Acquiring spectra'
    host.programs.spectra.start_time = dt_tm_tojs(systime())
    
;---Return if we already have an instance running:
    wid_pool, 'SDI Program - Exposure: Spectra', widx, /get
    if widget_info(widx, /valid_id) then begin
       return
    endif

;---Create the exposure meter:
    wtitle = 'SDI Program - Exposure: Spectra'
    wid_pool, 'sdi2k_top', widx, /get
    wid_pool, instance.description, sidx, /get
    top = WIDGET_BASE(title=wtitle, /column, group=sidx)
    expmet = widget_slider(top, xsize=280, title="Exposure Percent")
;---Register the plot xwindow name and top-level widget index with "wid_pool":
    wid_pool, 'spectra_exposure_slider', expmet, /add
    wid_pool, 'SDI Program - Exposure: Spectra', top, /add
    widget_control, top, /realize
    widget_control, top, set_uvalue={s_expm, wtitle: wtitle}
end

;==========================================================================================
; This is the (required) class method for creating a new instance of the sdi2k_prog_spex object. It
; would normally be an empty procedure.  Nevertheless, it MUST be present, as the last procedure in 
; the methods file, and it MUST have the same name as the methods file.  By calling this
; procedure, the caller forces all preceeding routines in the methods file to be compiled, 
; and so become available for subsequent use:

pro sdi2k_prog_spex
end

