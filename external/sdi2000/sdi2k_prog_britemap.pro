; >>>> begin comments
;==========================================================================================
;
; >>>> McObject Class: sdi2k_prog_britemap
;
; This file contains the McObject method code for sdi2k_prog_britemap objects:
;
; Mark Conde (Mc), Fairbanks, September 2000.
;
; >>>> end comments
; >>>> begin declarations
;         menu_name = Display Brightness Map
;        class_name = sdi2k_prog_britemap
;       description = SDI Program - Brightness Map
;           purpose = SDI operation
;       idl_version = 5.2
;  operating_system = Windows NT4.0 terminal server 
;            author = Mark Conde
; >>>> end declarations


;==========================================================================================
; This is the (required) "new" method for this McObject:

pro sdi2k_prog_britemap_new, instance, dynamic=dyn, creator=cmd
;---First, properties specific to this object:
    cmd = 'instance = {sdi2k_prog_britemap, '
    cmd = cmd + 'specific_cleanup: ''sdi2k_prog_britemap_specific_cleanup'', '    
;---Now add fields common to all SDI objects. These will be grouped as sub-structures:
    sdi2k_common_fields, cmd, automation=automation, geometry=geometry
;---Next, add the required fields, whose specifications are read from the 'declarations'
;   section of the comments at the top of this file:
    whoami, dir, file    
    obj_reqfields, dir+file, cmd, dynamic=dyn
;---Now, create the instance:
    status = execute(cmd)
end

;==========================================================================================
; This is the event handler for events generated by the sdi2k_prog_britemap object:
pro sdi2k_prog_britemap_event, event
@sdi2kinc.pro
    widget_control, event.top, get_uvalue=info
    wid_pool, 'Settings: ' + info.wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=britemap_settings
    if widget_info(event.id, /valid_id) and britemap_settings.automation.show_on_refresh then widget_control, event.id, /show

;---Get the programmed stop time:
    if strupcase(strcompress(host.programs.spectra.observation_type, /remove_all)) eq 'INS' then begin
       stoptime = host.operation.times.calibration_times(1)
    endif else begin
       stoptime = host.operation.times.observing_times(1)
    endelse
    
;---Check for a timer tick:    
    if tag_names(event, /structure_name) eq 'WIDGET_TIMER' then begin
       sdi2k_prog_britemap_tik, info.wtitle
       if britemap_settings.automation.timer_ticking then widget_control, widx, timer=britemap_settings.automation.timer_interval
       return
    endif
    
;---Check for a new frame event sent by the control module:
    nm      = 0
    matched = where(tag_names(event) eq 'NAME', nm)
    if nm gt 0 then begin
       if event.(matched(0)) eq 'NewFrame' then begin
          sdi2k_prog_britemap_tik, info.wtitle
          return
       endif
       if event.(matched(0)) eq 'Exposure Completed' then begin
          sdi2k_prog_britemap_exposure_done, info.wtitle
;---------We put the test for stop time here, so that we will only stop at the end of an exposure:
          jsnow = dt_tm_tojs(systime())
          if jsnow gt stoptime then begin
             wid_pool, info.wtitle, self, /destroy
          endif
          return
       endif
    endif

;---Get the menu name for this event:
    widget_control, event.id, get_uvalue=menu_item
    if n_elements(menu_item) eq 0 then menu_item = 'Nothing valid was selected'
end

;==========================================================================================
; This is the routine that updates the actual plot:
pro sdi2k_prog_britemap_tik, wtitle, redraw=redraw, _extra=_extra
@sdi2kinc.pro

;---Get settings information for this instance of the output xwindow and this instance of 
;   the plot program itself:
    wid_pool, wtitle, widx, /get
    if not(widget_info(widx, /valid_id)) then return
    widget_control, widx, get_uvalue=info
    wid_pool, 'Settings: ' + wtitle, sidx, /get
    if not(widget_info(sidx, /valid_id)) then return
    widget_control, sidx, get_uvalue=britemap_settings

    if !d.name ne 'Z' and !d.name ne 'PS' then wset, info.wid
;---If we have just finished a scan, update the spectra, and check for end time:
    if host.hardware.etalon.current_channel eq host.hardware.etalon.scan_channels-1  or $
       (!d.name eq 'Z' or !d.name eq 'PS') then begin
       nz = fix(total(host.operation.zones.sectors(0:host.operation.zones.fov_rings-1)))
       bmap = fltarr(n_elements(view(*,0)), n_elements(view(0,*)))
       erase
       totsig = 0.
       zsum = fltarr(nz)
       for j=0,nz-1 do begin
           zsum(j) = total(spectra(j,*) - min(mc_im_sm(spectra(j,*), 8)))
           totsig = totsig + zsum(j)
           nn = zone_table(j, 0)
           bmap(zone_table(j, 1:nn)) = zsum(j)/insbrite(j)
       endfor
       !p.position =  0
       delsec= dt_tm_tojs(systime()) - host.programs.spectra.start_time
       tv, host.colors.imgmin + bmap/(1e3*delsec)
       xyouts, 0.05, 0.95, 'Exposure: ' + strcompress(string(host.operation.header.records)), $
               align=0, /normal, color=host.colors.white, charthick=1, charsize=1
       xyouts, 0.95, 0.95, 'Scans: ' + strcompress(string(1+host.programs.spectra.etalon_scans)), $
               align=1, /normal, color=host.colors.white, charthick=1, charsize=1
       frate = total(spectra)/(1e6*delsec)
       srate = totsig/(1e6*delsec)
       brate = frate - srate
       xyouts, 0.03, 0.03, strcompress(string(srate, format='(f8.2)') + ' MHz'), $
               align=0, /normal, color=host.colors.white, charthick=1, charsize=1
       xyouts, 0.97, 0.05,  dt_tm_mk(js2jd(0d)+1,  host.programs.spectra.start_time, format='h$:m$:s$') +  '!C' + $
                            dt_tm_mk(js2jd(0d)+1, dt_tm_tojs(systime()), format='h$:m$:s$'), $
               align=1, /normal, color=host.colors.white, charthick=1, charsize=1
       xyouts, 0.5, 0.05, 'N', align=0.5, /normal, color=host.colors.white, charthick=2, charsize=1.5
       xyouts, 0.5, 0.94, 'S', align=0.5, /normal, color=host.colors.white, charthick=2, charsize=1.5
       xyouts, 0.05, 0.5, 'W', align=0.5, /normal, color=host.colors.white, charthick=2, charsize=1.5
       xyouts, 0.95, 0.5, 'E', align=0.5, /normal, color=host.colors.white, charthick=2, charsize=1.5
;------Make a GIF (if gif-ing is active):
       sdi2k_plugin_gif, info
    endif

    widget_control, sidx, set_uvalue=britemap_settings
end

;==========================================================================================
;   Cleanup jobs:
pro sdi2k_prog_britemap_specific_cleanup, widid
@sdi2kinc.pro
    sdi2k_set_shutters, camera='closed', laser='closed'
    sdi2k_ncdf_close
end


;==========================================================================================
; This is the (required) "autorun" method for this McObject. If no autorun action is 
; needed, then this routine should simply exit with no action:

pro sdi2k_prog_britemap_autorun, instance
@sdi2kinc.pro
    instance.geometry.xsize = n_elements(view(*,0))
    instance.geometry.ysize = n_elements(view(0,*))
    instance.automation.timer_interval = 1.
    instance.automation.timer_ticking = 0
    if n_elements(zone_map) eq 0 then return
    if n_elements(insbrite) eq 0 then return
    
    if n_elements(spectra) eq 0 then sdi2k_reset_spectra
    mnu_xwindow_autorun, instance, topname='sdi2k_top'
end

;==========================================================================================
; This is the (required) class method for creating a new instance of the sdi2k_prog_britemap object. It
; would normally be an empty procedure.  Nevertheless, it MUST be present, as the last procedure in 
; the methods file, and it MUST have the same name as the methods file.  By calling this
; procedure, the caller forces all preceeding routines in the methods file to be compiled, 
; and so become available for subsequent use:

pro sdi2k_prog_britemap
end

